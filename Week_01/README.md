# week1学习总结
## 1. 关于复杂度
       时间复杂度和空间复杂度是用来衡量某种算法性能的两种不同维度的指标。算法的时间和空间复杂度越低性能就越高，即消耗的时间和所需的内存资源不会随着算法执行规模的不断增大而显著增加。

       比如：从1到n的等差数列求和计算。当使用循环计算的方式时，计算执行的时间是随着n的增长而增长的。而使用求和公式的方式不管n有多大计算执行的时间是不变的，也就是执行一条公式的时间。这里的求和方式在性能上就比循环计算的方式要高。

       所以在平常的代码实现上要刻意地有意识地去考虑其时间和空间的复杂度，尽最大可能提高代码的性能。

## 2. 关于数组 链表 跳表
- **数组**: 每个元素与物理存储地址相关联，存储地址连续，故已知索引情况下可立即访问元素，也因此在数组中插入或者删除元素需要群移操作。
    1. 访问：O(1)
    2. 查找：O(n)
    3. 插入：O(n)
    4. 删除：O(n)

- **链表**: 与数组相比每个元素的物理存储地址可以不连续，所以每个元素均有一个额外的指针用于指向下一个元素的地址使得表能够连续下去，这也使得链表比数组需要更多的空间。但通过指针连接的方式能够方便地插入和删除元素。
    1. 访问：O(n)
    2. 查找：O(n)
    3. 插入：O(1)
    4. 删除：O(1)

- **跳表**: 在链表的基础上使用升维的方式来加速链表查找的速度，但同时使得插入和删除操作更慢
    1. 访问：O(log(n))
    2. 查找：O(log(n))
    3. 插入：O(log(n))
    4. 删除：O(log(n))


## 3. 关于栈与队列
- **栈**: 特点是只能在线性表的一端进行添加和删除操作，即按照后进先出的原则进行。最常见的应用是程序在运行时给函数嵌套调用时内存的分配方式。
    1. 访问：O(n)
    2. 查找：O(n)
    3. 插入：O(1)
    4. 删除：O(1)

- **队列**: 特点是只能在线性表的一端进行添加，另一端进行删除操作，即按照先进先出的原则进行。比如等待处理的通讯缓冲队列
    1. 访问：O(n)
    2. 查找：O(n)
    3. 插入：O(1)
    4. 删除：O(1)

    基于以上，在应用时要根据各种数据结构的特点进行选择。
    
    这周的习题练习没有达到理想的状态，覃超老师的五毒神掌还需加强多加练习，争取接下来的一周能够跟上节奏。